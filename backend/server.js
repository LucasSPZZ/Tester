const express = require('express');
const cors = require('cors');
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '10mb' })); // Aumentar limite para schema grandes

// Inicializar Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/* 
MODELOS UTILIZADOS:
- gemini-2.5-pro: Para gera√ß√£o de c√≥digo SQL (m√°xima qualidade e precis√£o)
- gemini-2.5-flash: Para entendimento de fun√ß√µes (m√°xima velocidade e efici√™ncia)
*/

// System prompt base
const SYSTEM_PROMPT = `Voc√™ √© o "RPCraft AI", um assistente de desenvolvimento especialista em PostgreSQL e Supabase. Sua √∫nica fun√ß√£o √© gerar c√≥digo SQL (PL/pgSQL) para criar ou modificar fun√ß√µes RPC. Voc√™ deve seguir estas regras rigorosamente:

1. **An√°lise de Contexto:** Abaixo, voc√™ receber√° um contexto completo do banco de dados, incluindo a lista de todas as tabelas, suas colunas, e o c√≥digo-fonte de todas as fun√ß√µes RPC existentes. Use este contexto como sua √∫nica fonte de verdade para entender a estrutura do banco.

2. **Identifica√ß√£o da Tarefa:** A instru√ß√£o do usu√°rio determinar√° a sua tarefa:
   * **Se for para EDITAR uma fun√ß√£o:** O prompt incluir√° o c√≥digo-fonte da "Fun√ß√£o Alvo". Sua tarefa √© reescrever este c√≥digo-fonte aplicando a modifica√ß√£o solicitada pelo usu√°rio.
   * **Se for para CRIAR uma nova fun√ß√£o:** N√£o haver√° uma "Fun√ß√£o Alvo". Sua tarefa √© escrever o c√≥digo para uma fun√ß√£o completamente nova, do zero, com base na descri√ß√£o do usu√°rio e no contexto do banco.

3. **Formato da Sa√≠da (Regra Mais Importante):**
   * Sua resposta DEVE conter APENAS o c√≥digo SQL completo da fun√ß√£o.
   * O c√≥digo deve estar dentro de um √∫nico bloco de c√≥digo markdown para SQL.
   * N√ÉO inclua nenhuma explica√ß√£o, texto introdut√≥rio, sauda√ß√µes ou coment√°rios de despedida. Sua resposta √© o c√≥digo, e nada mais.

4. **Boas Pr√°ticas e Seguran√ßa:**
   * Sempre que poss√≠vel, use \`SECURITY DEFINER\` em fun√ß√µes que precisam de permiss√µes elevadas para acessar dados em m√∫ltiplas tabelas. Use \`SECURITY INVOKER\` para fun√ß√µes que devem operar com as permiss√µes do usu√°rio que as chama.
   * Certifique-se de que os nomes dos par√¢metros nas suas fun√ß√µes n√£o colidam com nomes de colunas das tabelas para evitar ambiguidades.
   * Escreva c√≥digo limpo, leg√≠vel e eficiente.`;

// System prompt para entender fun√ß√µes
const UNDERSTAND_FUNCTION_PROMPT = `Voc√™ √© um especialista em banco de dados que explica fun√ß√µes SQL de forma simples e clara. Sua tarefa √© analisar uma fun√ß√£o PostgreSQL/PL-pgSQL e explicar o que ela faz em linguagem que qualquer pessoa possa entender, mesmo sem conhecimento t√©cnico.

REGRAS IMPORTANTES:
1. Use linguagem SIMPLES e CLARA - evite jarg√µes t√©cnicos
2. Explique como se estivesse falando com algu√©m que n√£o programa porem tem conhecimento b√°sico de banco de dados.
3. Especifique de qual tabela e qual coluna esta pegando o dado
4. Seja direto e objetivo
5. Use par√°grafos curtos e organize bem o texto
6. Fale sobre quais par√¢metros esta fun√ß√£o recebe e quais s√£o obrigat√≥rios.

FORMATO DA RESPOSTA:
- Comece com: "Esta fun√ß√£o..."
- Explique o prop√≥sito principal em 1-2 frases
- Se necess√°rio, detalhe os passos principais
- Termine explicando o que ela retorna/produz
- Ao detalhar os passos sempre utilize paragrafos entre os passos

EXEMPLO DE BOA EXPLICA√á√ÉO:
"Esta fun√ß√£o recebe como parametro o salon_id com base nisso ela procura na tabela appointments todos os funcionarios que tem o salon_id informado e retorna todos eles na resposta final."`;

// System prompt espec√≠fico para tabelas
const TABLE_SYSTEM_PROMPT = `Voc√™ √© o RPCraft AI, um especialista em design de banco de dados PostgreSQL/Supabase.

Sua especialidade √© criar e modificar estruturas de tabelas PostgreSQL de forma eficiente e seguindo as melhores pr√°ticas.

## REGRAS IMPORTANTES:

1. **AN√ÅLISE DE CONTEXTO**: Analise o schema existente para entender:
   - Tabelas relacionadas
   - Conven√ß√µes de nomenclatura
   - Padr√µes de chaves prim√°rias/estrangeiras
   - Estrutura de dados existente

2. **IDENTIFICA√á√ÉO DA TAREFA**: Determine se √© para:
   - Criar nova tabela
   - Modificar tabela existente (ADD COLUMN, ALTER COLUMN, etc)
   - Criar √≠ndices
   - Configurar relacionamentos
   - Aplicar RLS (Row Level Security)

3. **BOAS PR√ÅTICAS**:
   - Use conven√ß√µes de nomenclatura consistentes (snake_case)
   - Sempre inclua created_at e updated_at quando apropriado
   - Configure RLS quando necess√°rio para seguran√ßa
   - Crie √≠ndices para colunas que ser√£o consultadas frequentemente
   - Use tipos de dados apropriados (UUID para IDs, TIMESTAMPTZ para datas)
   - Adicione coment√°rios explicativos

4. **FORMATO DE SA√çDA**:
   - Retorne APENAS c√≥digo SQL v√°lido
   - Sem explica√ß√µes ou coment√°rios introdut√≥rios
   - Use formata√ß√£o SQL limpa e leg√≠vel
   - Inclua todas as instru√ß√µes necess√°rias (CREATE, ALTER, INDEX, RLS, etc)

5. **RELACIONAMENTOS**:
   - Identifique relacionamentos impl√≠citos no prompt
   - Configure foreign keys apropriadamente
   - Considere CASCADE quando fizer sentido

6. **SEGURAN√áA**:
   - Configure RLS quando apropriado
   - Crie pol√≠ticas de seguran√ßa b√°sicas
   - Use tipos apropriados para dados sens√≠veis

Analise o prompt e retorne o SQL mais adequado e completo.`;

// Fun√ß√£o para formatar o schema do banco
function formatDatabaseSchema(schema) {
  console.log('\nüèóÔ∏è  FORMATANDO SCHEMA DO BANCO:');
  console.log('- Tabelas encontradas:', schema.tables?.length || 0);
  console.log('- Fun√ß√µes encontradas:', schema.functions?.length || 0);
  
  let formattedSchema = "\n## CONTEXTO DO BANCO DE DADOS\n\n";
  
  // Adicionar tabelas
  formattedSchema += "### TABELAS:\n\n";
  if (schema.tables && schema.tables.length > 0) {
    schema.tables.forEach(table => {
      formattedSchema += `**Tabela: ${table.name}**\n`;
      if (table.columns && table.columns.length > 0) {
        formattedSchema += "Colunas:\n";
        table.columns.forEach(column => {
          formattedSchema += `- ${column.name}: ${column.type}\n`;
        });
      }
      formattedSchema += "\n";
    });
  }
  
  // Adicionar fun√ß√µes RPC existentes
  formattedSchema += "### FUN√á√ïES RPC EXISTENTES:\n\n";
  if (schema.functions && schema.functions.length > 0) {
    schema.functions.forEach((func, index) => {
      formattedSchema += `**${index + 1}. Fun√ß√£o: ${func.name}**\n`;
      formattedSchema += "```sql\n";
      formattedSchema += func.source;
      formattedSchema += "\n```\n\n";
    });
  }
  
  console.log('- Schema formatado com sucesso ‚úÖ');
  
  return formattedSchema;
}

// Fun√ß√£o para formatar apenas o schema das tabelas (sem fun√ß√µes RPC)
function formatTablesOnlySchema(schema) {
  console.log('\nüèóÔ∏è  FORMATANDO APENAS SCHEMA DAS TABELAS:');
  console.log('- Tabelas encontradas:', schema.tables?.length || 0);
  console.log('- Fun√ß√µes RPC: IGNORADAS (apenas para entender fun√ß√£o espec√≠fica)');
  
  let formattedSchema = "\n## CONTEXTO DO BANCO DE DADOS\n\n";
  
  // Adicionar apenas tabelas
  formattedSchema += "### TABELAS DO BANCO:\n\n";
  if (schema.tables && schema.tables.length > 0) {
    schema.tables.forEach(table => {
      formattedSchema += `**Tabela: ${table.name}**\n`;
      if (table.columns && table.columns.length > 0) {
        formattedSchema += "Colunas:\n";
        table.columns.forEach(column => {
          formattedSchema += `- ${column.name}: ${column.type}\n`;
        });
      }
      formattedSchema += "\n";
    });
  }
  
  console.log('- Schema das tabelas formatado com sucesso ‚úÖ');
  
  return formattedSchema;
}

// Endpoint principal para gerar c√≥digo SQL
app.post('/api/generate-sql', async (req, res) => {
  try {
    const { schema, userPrompt, targetFunction, geminiApiKey } = req.body;
    
    // LOG: Dados recebidos
    console.log('\n' + '='.repeat(80));
    console.log('üîÑ NOVA REQUISI√á√ÉO PARA GERAR SQL');
    console.log('='.repeat(80));
    console.log('üìä DADOS RECEBIDOS:');
    console.log('- User Prompt:', userPrompt);
    console.log('- Target Function:', targetFunction ? 'SIM (Edi√ß√£o)' : 'N√ÉO (Cria√ß√£o)');
    console.log('- Schema Tables:', schema?.tables?.length || 0);
    console.log('- Schema Functions:', schema?.functions?.length || 0);
    console.log('- Custom Gemini API Key:', geminiApiKey ? 'SIM (Personalizada)' : 'N√ÉO (Padr√£o do sistema)');
    
    // Validar entrada
    if (!schema || !userPrompt) {
      console.log('‚ùå ERRO: Schema ou userPrompt n√£o fornecidos');
      return res.status(400).json({
        error: 'Schema e userPrompt s√£o obrigat√≥rios'
      });
    }

    // Usar API key personalizada ou padr√£o do sistema
    const apiKeyToUse = geminiApiKey || process.env.GEMINI_API_KEY;
    
    if (!apiKeyToUse) {
      console.log('‚ùå ERRO: Nenhuma API key dispon√≠vel (nem personalizada nem padr√£o)');
      return res.status(400).json({
        error: 'API key do Gemini √© obrigat√≥ria. Configure uma chave personalizada ou configure GEMINI_API_KEY no servidor.'
      });
    }

    // Inicializar Gemini com a API key apropriada
    const customGenAI = new GoogleGenerativeAI(apiKeyToUse);
    
    // Montar o prompt completo
    let fullPrompt = SYSTEM_PROMPT;
    
    // Adicionar contexto do banco
    fullPrompt += formatDatabaseSchema(schema);
    
    // Adicionar fun√ß√£o alvo se for edi√ß√£o
    if (targetFunction) {
      fullPrompt += "\n## FUN√á√ÉO ALVO PARA EDI√á√ÉO:\n\n";
      fullPrompt += "```sql\n";
      fullPrompt += targetFunction;
      fullPrompt += "\n```\n\n";
    }
    
    // Adicionar instru√ß√£o do usu√°rio
    fullPrompt += "\n## INSTRU√á√ÉO DO USU√ÅRIO:\n\n";
    fullPrompt += userPrompt;
    
    // LOG: Prompt completo enviado para a LLM
    console.log('\nüì§ PROMPT COMPLETO ENVIADO PARA GEMINI:');
    console.log('-'.repeat(80));
    console.log(fullPrompt);
    console.log('-'.repeat(80));
    console.log('üìè Tamanho do prompt:', fullPrompt.length, 'caracteres');
    console.log('üîë API Key utilizada:', apiKeyToUse.substring(0, 10) + '...');
    
    // Configurar o modelo Gemini
    const model = customGenAI.getGenerativeModel({ 
      model: "gemini-2.5-pro",
      generationConfig: {
        temperature: 0.1, // Baixa temperatura para c√≥digo mais consistente
        maxOutputTokens: 8192,
      }
    });
    
    console.log('\nü§ñ ENVIANDO PARA GEMINI...');
    
    // Gerar resposta
    const result = await model.generateContent(fullPrompt);
    const response = await result.response;
    const generatedSQL = response.text();
    
    // LOG: Resposta recebida da LLM
    console.log('\nüì• RESPOSTA RECEBIDA DO GEMINI:');
    console.log('-'.repeat(80));
    console.log(generatedSQL);
    console.log('-'.repeat(80));
    console.log('üìè Tamanho da resposta:', generatedSQL.length, 'caracteres');
    console.log('üìä Tokens utilizados:', result.response.usageMetadata || 'N√£o dispon√≠vel');
    console.log('‚úÖ PROCESSAMENTO CONCLU√çDO COM SUCESSO!');
    console.log('='.repeat(80) + '\n');
    
    // Retornar resposta
    res.json({
      success: true,
      sql: generatedSQL,
      tokensUsed: result.response.usageMetadata || null
    });
    
  } catch (error) {
    console.log('\n‚ùå ERRO NO PROCESSAMENTO:');
    console.log('-'.repeat(80));
    console.error('Detalhes do erro:', error);
    console.log('-'.repeat(80));
    console.log('='.repeat(80) + '\n');
    
    // Tratar diferentes tipos de erro
    if (error.message.includes('API key')) {
      return res.status(401).json({
        error: 'Chave da API do Gemini inv√°lida ou n√£o configurada'
      });
    }
    
    if (error.message.includes('quota')) {
      return res.status(429).json({
        error: 'Quota da API excedida. Tente novamente mais tarde.'
      });
    }
    
    res.status(500).json({
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Endpoint de health check
app.get('/api/health', (req, res) => {
  console.log('ü©∫ Health check solicitado');
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'RPCraft Backend'
  });
});

// Endpoint para testar a API do Gemini
app.get('/api/test-gemini', async (req, res) => {
  console.log('üß™ Teste do Gemini solicitado');
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
    const result = await model.generateContent("Responda apenas 'OK' se voc√™ est√° funcionando.");
    const response = await result.response;
    
    console.log('‚úÖ Gemini Flash respondeu:', response.text());
    
    res.json({
      success: true,
      response: response.text(),
      message: 'Gemini API est√° funcionando corretamente'
    });
  } catch (error) {
    console.log('‚ùå Erro no teste do Gemini:', error.message);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para entender o que uma fun√ß√£o faz
app.post('/api/understand-function', async (req, res) => {
  try {
    const { schema, functionCode, functionName, geminiApiKey } = req.body;
    
    // LOG: Dados recebidos
    console.log('\n' + '='.repeat(80));
    console.log('üß† NOVA REQUISI√á√ÉO PARA ENTENDER FUN√á√ÉO');
    console.log('='.repeat(80));
    console.log('üìä DADOS RECEBIDOS:');
    console.log('- Function Name:', functionName);
    console.log('- Schema Tables:', schema?.tables?.length || 0);
    console.log('- Schema Functions:', schema?.functions?.length || 0, '(N√ÉO SER√ÉO ENVIADAS)');
    console.log('- Function Code Length:', functionCode?.length || 0, 'characters');
    console.log('- Custom Gemini API Key:', geminiApiKey ? 'SIM (Personalizada)' : 'N√ÉO (Padr√£o do sistema)');
    
    // Validar entrada
    if (!schema || !functionCode || !functionName) {
      console.log('‚ùå ERRO: Dados insuficientes para an√°lise');
      return res.status(400).json({
        error: 'Schema, functionCode e functionName s√£o obrigat√≥rios'
      });
    }

    // Usar API key personalizada ou padr√£o do sistema
    const apiKeyToUse = geminiApiKey || process.env.GEMINI_API_KEY;
    
    if (!apiKeyToUse) {
      console.log('‚ùå ERRO: Nenhuma API key dispon√≠vel (nem personalizada nem padr√£o)');
      return res.status(400).json({
        error: 'API key do Gemini √© obrigat√≥ria. Configure uma chave personalizada ou configure GEMINI_API_KEY no servidor.'
      });
    }

    // Inicializar Gemini com a API key apropriada
    const customGenAI = new GoogleGenerativeAI(apiKeyToUse);
    
    // Montar o prompt completo
    let fullPrompt = UNDERSTAND_FUNCTION_PROMPT;
    
    // Adicionar contexto do banco (APENAS TABELAS)
    fullPrompt += formatTablesOnlySchema(schema);
    
    // Adicionar a fun√ß√£o a ser analisada
    fullPrompt += "\n## FUN√á√ÉO A SER ANALISADA:\n\n";
    fullPrompt += `**Nome da Fun√ß√£o:** ${functionName}\n\n`;
    fullPrompt += "**C√≥digo da Fun√ß√£o:**\n```sql\n";
    fullPrompt += functionCode;
    fullPrompt += "\n```\n\n";
    
    // Adicionar instru√ß√£o final
    fullPrompt += "\n## INSTRU√á√ÉO:\n\n";
    fullPrompt += `Analise a fun√ß√£o "${functionName}" acima e explique o que ela faz em linguagem simples, seguindo as regras estabelecidas. Lembre-se de usar analogias do dia a dia e evitar jarg√µes t√©cnicos.`;
    
    // LOG: Prompt completo enviado para a LLM
    console.log('\nüì§ PROMPT COMPLETO ENVIADO PARA GEMINI FLASH (UNDERSTAND):');
    console.log('‚ÑπÔ∏è  CONTEXTO: Apenas schema das tabelas (sem c√≥digo de outras fun√ß√µes)');
    console.log('‚ö° MODELO: gemini-2.5-flash (otimizado para velocidade)');
    console.log('-'.repeat(80));
    console.log(fullPrompt);
    console.log('-'.repeat(80));
    console.log('üìè Tamanho do prompt:', fullPrompt.length, 'caracteres');
    console.log('üîë API Key utilizada:', apiKeyToUse.substring(0, 10) + '...');
    
    // Configurar o modelo Gemini
    const model = customGenAI.getGenerativeModel({ 
      model: "gemini-2.5-flash", // Usando Flash para entendimento (mais r√°pido e barato)
      generationConfig: {
        temperature: 0.3, // Temperatura um pouco mais alta para explica√ß√µes mais naturais
        maxOutputTokens: 4096,
      }
    });
    
    console.log('\nü§ñ ENVIANDO PARA GEMINI FLASH (UNDERSTAND)...');
    
    // Gerar resposta
    const result = await model.generateContent(fullPrompt);
    const response = await result.response;
    const explanation = response.text();
    
    // LOG: Resposta recebida da LLM
    console.log('\nüì• EXPLICA√á√ÉO RECEBIDA DO GEMINI FLASH:');
    console.log('-'.repeat(80));
    console.log(explanation);
    console.log('-'.repeat(80));
    console.log('üìè Tamanho da explica√ß√£o:', explanation.length, 'caracteres');
    console.log('üìä Tokens utilizados:', result.response.usageMetadata || 'N√£o dispon√≠vel');
    console.log('‚úÖ AN√ÅLISE CONCLU√çDA COM SUCESSO!');
    console.log('='.repeat(80) + '\n');
    
    // Retornar resposta
    res.json({
      success: true,
      explanation: explanation,
      tokensUsed: result.response.usageMetadata || null
    });
    
  } catch (error) {
    console.log('\n‚ùå ERRO NA AN√ÅLISE DA FUN√á√ÉO:');
    console.log('-'.repeat(80));
    console.error('Detalhes do erro:', error);
    console.log('-'.repeat(80));
    console.log('='.repeat(80) + '\n');
    
    // Tratar diferentes tipos de erro
    if (error.message.includes('API key')) {
      return res.status(401).json({
        error: 'Chave da API do Gemini inv√°lida ou n√£o configurada'
      });
    }
    
    if (error.message.includes('quota')) {
      return res.status(429).json({
        error: 'Quota da API excedida. Tente novamente mais tarde.'
      });
    }
    
    res.status(500).json({
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Endpoint para gera√ß√£o de SQL de tabelas
app.post('/api/generate-table-sql', async (req, res) => {
  console.log('\n=== GERA√á√ÉO DE SQL PARA TABELA ===');
  console.log('Dados recebidos:', {
    hasSchema: !!req.body.schema,
    tablesCount: req.body.schema?.tables?.length || 0,
    functionsCount: req.body.schema?.functions?.length || 0,
    prompt: req.body.prompt,
    type: req.body.type,
    tableName: req.body.tableName,
    customGeminiApiKey: req.body.geminiApiKey ? 'SIM (Personalizada)' : 'N√ÉO (Padr√£o do sistema)'
  });

  try {
    const { schema, prompt, type, tableName, geminiApiKey } = req.body;

    if (!schema || !prompt) {
      return res.status(400).json({
        success: false,
        error: 'Schema e prompt s√£o obrigat√≥rios'
      });
    }

    // Usar API key personalizada ou padr√£o do sistema
    const apiKeyToUse = geminiApiKey || process.env.GEMINI_API_KEY;
    
    if (!apiKeyToUse) {
      console.log('‚ùå ERRO: Nenhuma API key dispon√≠vel (nem personalizada nem padr√£o)');
      return res.status(400).json({
        success: false,
        error: 'API key do Gemini √© obrigat√≥ria. Configure uma chave personalizada ou configure GEMINI_API_KEY no servidor.'
      });
    }

    // Inicializar Gemini com a API key apropriada
    const customGenAI = new GoogleGenerativeAI(apiKeyToUse);

    // Formatar schema do banco espec√≠fico para tabelas
    const formattedSchema = formatDatabaseSchemaForTables(schema);
    
    // Criar prompt espec√≠fico baseado no tipo de opera√ß√£o
    let contextualPrompt = '';
    if (type === 'edit_table' && tableName) {
      contextualPrompt = `TABELA ALVO: ${tableName}
OPERA√á√ÉO: Modificar tabela existente
DESCRI√á√ÉO: ${prompt}

${formattedSchema}`;
    } else {
      contextualPrompt = `OPERA√á√ÉO: Criar nova tabela
DESCRI√á√ÉO: ${prompt}

${formattedSchema}`;
    }

    console.log('Prompt completo enviado para Gemini:');
    console.log('='.repeat(80));
    console.log(contextualPrompt);
    console.log('='.repeat(80));
    console.log('üîë API Key utilizada:', apiKeyToUse.substring(0, 10) + '...');

    // Configurar Gemini para tabelas
    const model = customGenAI.getGenerativeModel({ 
      model: "gemini-2.0-flash-exp",
      systemInstruction: TABLE_SYSTEM_PROMPT
    });

    const result = await model.generateContent(contextualPrompt);
    const response = await result.response;
    const sqlCode = response.text();

    console.log('Resposta recebida da LLM:');
    console.log('-'.repeat(40));
    console.log(sqlCode);
    console.log('-'.repeat(40));
    
    if (result.response.usageMetadata) {
      console.log('Tokens utilizados:', result.response.usageMetadata);
    }

    res.json({
      success: true,
      sql: sqlCode.trim()
    });

  } catch (error) {
    console.error('Erro ao gerar SQL da tabela:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Fun√ß√£o para formatar schema espec√≠fico para tabelas (mais focado)
function formatDatabaseSchemaForTables(schema) {
  let formattedSchema = `## SCHEMA DO BANCO DE DADOS

### TABELAS EXISTENTES:
`;

  // Listar tabelas com informa√ß√µes essenciais
  schema.tables.forEach(table => {
    formattedSchema += `
#### ${table.name} (${table.schema})
COLUNAS:`;
    
    table.columns.forEach(column => {
      const constraints = [];
      if (column.isPrimaryKey) constraints.push('PK');
      if (column.isForeignKey) constraints.push('FK');
      if (!column.nullable) constraints.push('NOT NULL');
      
      const constraintStr = constraints.length > 0 ? ` [${constraints.join(', ')}]` : '';
      formattedSchema += `
  - ${column.name}: ${column.type}${constraintStr}`;
      
      if (column.defaultValue) {
        formattedSchema += ` DEFAULT ${column.defaultValue}`;
      }
    });
    formattedSchema += '\n';
  });

  // Incluir informa√ß√µes resumidas das fun√ß√µes (podem ser relevantes para triggers)
  if (schema.functions && schema.functions.length > 0) {
    formattedSchema += `
### FUN√á√ïES DISPON√çVEIS:
`;
    schema.functions.slice(0, 10).forEach(func => { // Apenas as primeiras 10 para n√£o sobrecarregar
      formattedSchema += `- ${func.name}(${func.parameters.map(p => `${p.name} ${p.type}`).join(', ')}) ‚Üí ${func.returnType}\n`;
    });
    
    if (schema.functions.length > 10) {
      formattedSchema += `... e mais ${schema.functions.length - 10} fun√ß√µes\n`;
    }
  }

  return formattedSchema;
}

// Iniciar servidor
app.listen(PORT, () => {
  console.log('\n' + '='.repeat(60));
  console.log('üöÄ RPCraft Backend Iniciado com Sucesso!');
  console.log('='.repeat(60));
  console.log(`üåê Servidor rodando na porta: ${PORT}`);
  console.log(`üîß Health check: http://localhost:${PORT}/api/health`);
  console.log(`ü§ñ Gemini test: http://localhost:${PORT}/api/test-gemini`);
  console.log(`üì° Generate SQL: POST http://localhost:${PORT}/api/generate-sql`);
  console.log(`üß† Understand Function: POST http://localhost:${PORT}/api/understand-function`);
  
  // Verificar se a API key est√° configurada
  if (!process.env.GEMINI_API_KEY) {
    console.log('\n‚ö†Ô∏è  ATEN√á√ÉO: GEMINI_API_KEY N√ÉO CONFIGURADA!');
    console.log('   üìù Crie um arquivo .env com: GEMINI_API_KEY=sua_chave_aqui');
  } else {
    console.log('\n‚úÖ GEMINI_API_KEY configurada corretamente');
    console.log('üîë API Key:', process.env.GEMINI_API_KEY.substring(0, 10) + '...');
  }
  
  console.log('\nüìã LOGS DETALHADOS ATIVADOS:');
  console.log('   - Todas as requisi√ß√µes ser√£o logadas');
  console.log('   - Prompt completo enviado para Gemini ser√° exibido');
  console.log('   - Resposta da LLM ser√° mostrada no console');
  console.log('   - Generate SQL: gemini-2.5-pro (m√°xima qualidade)');
  console.log('   - Understand Function: gemini-2.5-flash (m√°xima velocidade)');
  console.log('='.repeat(60));
  console.log('üéß Aguardando requisi√ß√µes...\n');
}); 